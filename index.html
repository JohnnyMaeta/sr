<!doctype html><meta charset="utf-8">
<title>Screen Recorder → GAS</title>
<style>
  body{font-family:system-ui;padding:16px}
  button{padding:8px 12px;margin-right:8px}
  video{width:100%;max-width:720px;background:#000;margin-top:8px}
  #status{margin-top:8px}
</style>

<h2>画面録画 → Drive保存（このシートに記録）</h2>
<div>
  <button id="start">録画開始</button>
  <button id="stop" disabled>停止</button>
  <button id="upload" disabled>Driveに保存</button>
</div>
<div style="margin-top:8px">
  <label>ファイル名 <input id="fname" value="screen-record.webm"></label>
  <label style="margin-left:8px">音声 <input type="checkbox" id="withAudio" checked></label>
  <label style="margin-left:8px">ビットレート
    <select id="bitrate">
      <option value="2500000">2.5 Mbps</option>
      <option value="1500000" selected>1.5 Mbps</option>
      <option value="800000">0.8 Mbps</option>
    </select>
  </label>
</div>
<video id="v" controls playsinline></video>
<div id="status"></div>

<script>
const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycbyfb4UKROiYGtOIfvaCubqNpR6pUKRab39hz4lt4PxE9YpBrsFGllicgWy50ZJEWyuJ/exec';
const TOKEN = 'mikireiemoto';

let rec, chunks=[], blob, startAt;

const $ = id => document.getElementById(id);
const say = t => $.status.textContent = t;

$.start.onclick = async () => {
  try{
    const stream = await navigator.mediaDevices.getDisplayMedia({
      video:{ frameRate:30 },
      audio: $.withAudio.checked
    });
    const br = +$.bitrate.value;
    const mtype = MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus')
      ? 'video/webm;codecs=vp9,opus' : 'video/webm;codecs=vp8,opus';

    rec = new MediaRecorder(stream, { mimeType: mtype, videoBitsPerSecond: br });
    chunks = []; startAt = Date.now();

    rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
    rec.onstop = () => {
      blob = new Blob(chunks, { type: mtype });
      $.v.src = URL.createObjectURL(blob);
      $.upload.disabled = false;
      stream.getTracks().forEach(t=>t.stop());
      say(`録画完了: ${(blob.size/1024/1024).toFixed(2)}MB`);
    };

    rec.start(1000);
    $.start.disabled = true; $.stop.disabled = false; $.upload.disabled = true;
    say('録画中…');
  }catch(e){
    say('開始できません: ' + e.message);
  }
};

$.stop.onclick = () => {
  if (rec && rec.state !== 'inactive') {
    rec.stop();
    $.start.disabled = false; $.stop.disabled = true;
  }
};

$.upload.onclick = async () => {
  if (!blob) return;
  say('エンコード中…');
  const base64 = await toBase64(blob);
  say('アップロード中…');

  const meta = {
    filename: $.fname.value || 'screen-record.webm',
    mimeType: blob.type || 'video/webm',
    durationMs: Date.now() - startAt
  };
  const form = new FormData();
  form.append('token', TOKEN);
  form.append('meta', JSON.stringify(meta));
  form.append('data', base64);

  try{
    const res = await fetch(GAS_ENDPOINT, { method:'POST', body: form });
    const json = await res.json();
    if (json.ok) say('保存しました: ' + json.url);
    else say('失敗: ' + json.error);
  }catch(e){
    say('通信エラー: ' + e.message);
  }
};

function toBase64(blob){
  return new Promise((resolve,reject)=>{
    const r=new FileReader();
    r.onloadend=()=>resolve(r.result);
    r.onerror=reject;
    r.readAsDataURL(blob);
  });
}
</script>
